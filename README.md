# Описание процессов и переменных СРВС

## 1. Основные переменные и структуры

**Классы и структуры:**
- `TasksGenerator` — генератор задач.
- `TasksExecutor` — вычислитель, который решает задачи.
- `TasksController` — вспомогательные методы (сбор статистики, работа с очередями, расчет продуктивности и др.).
- `Task` — описание типов задач, методы для получения их характеристик.
- `PriorityQueue` — очередь подзадач.
- Различные классы для построения графиков: `SubtasksCountInTaskPlot`, `SubtasksCountInQueuePlot`, `InputFlowPlot`, `ProductivityPlot`.

**Главные переменные:**
- `subtasks_queue` — очередь подзадач (PriorityQueue).
- `subtask_array` — массив подзадач (proxy.list()).
- `failed_subtasks` — очередь неудачных подзадач.
- `solved_tasks` — список решённых задач по типам.
- `namespace` — общая память между процессами (proxy.Namespace()).
  - `each_type_created_tasks_count` — число созданных задач по типам.
  - `input_flow` — интенсивность входящего потока.
- `executor_namespace` — общая память для вычислителей.
  - `solved_tasks_checker_flag`, `each_type_solved_subtasks_count`, `each_type_failed_subtasks_count`, `each_type_wasted_tasks_count`, `actual_task_execution_time`, `productivity`.
- `subtasks_count_in_task_queue` — очередь для сбора статистики количества подзадач в задачах.
- `stop_event` — флаг остановки всех процессов.

## 2. Последовательность запуска процессов

**Основной поток (`main.py`):**
1. Чтение конфигурации.
2. Инициализация всех очередей, списков и пространств имен.
3. Создание экземпляров генератора задач, исполнительных и управляющих классов.
4. Запуск 4 процессов-генераторов задач (`TasksGenerator.generate_tasks`).
5. Запуск процесса отправки задач в общую очередь (`TasksController.send_subtasks_to_queue`).
6. Запуск 32 вычислителей (`TasksExecutor.execute_tasks`) — каждый отдельный процесс, имитирующий отдельный ИА.
7. Запуск процесса-обработчика флага проверки решённых задач (`TasksController.switch_solved_tasks_checker_flag`).
8. Запуск процесса сбора статистики очереди подзадач (`TasksController.subtasks_statistic`).
9. Запуск процесса расчёта продуктивности (`TasksController.calc_productivity`).
10. Запуск процессов построения графиков:
    - Количество подзадач в задачах (`SubtasksCountInTaskPlot.plot_subtasks_count_in_tasks_by_time`)
    - Количество подзадач в очереди (`SubtasksCountInQueuePlot.plot_subtasks_count_in_queue_by_time`)
    - Интенсивность входного потока (`InputFlowPlot.plot_input_flow`)
    - Продуктивность (`ProductivityPlot.plot_productivity`)

**Завершение работы:**  
При нажатии Ctrl+C или другой остановке, всем процессам посылается сигнал остановки (`stop_event.set()`), далее выполняется корректное завершение и очистка.

## 3. Принцип работы некоторых модулей

**Вычислитель (`TasksExecutor.execute_tasks`):**
- Получает задачу из очереди `subtasks_queue`.
- Проверяет, не была ли задача уже решена.
- Запускает вычисление задачи, замеряет время.
- Если задача решена — добавляет её метку времени в список решённых задач `solved_tasks[task_type]`.
- Если задача не решена — увеличивает счётчик неудач, отправляет задачу обратно в очередь с максимальным приоритетом.
- Если время выполнения превышено — задача отмечается как "затраченная впустую".
- Все вычисления и состояния отражаются в `executor_namespace`.

**сбор и вычисление статистики**

- Каждый процесс-вычислитель и генератор пишет свои данные в общие структуры (`namespace`, `executor_namespace`).
- Отдельные процессы-статистики (из `TasksController`) периодически опрашивают очереди/масивы и считают средние значения, суммарные показатели, продуктивность.
- Для визуализации все показатели передаются в отдельные процессы, строящие графики с помощью matplotlib.


## 4. Сбор и вычисление статистических данных

- **Сбор статистики по очереди:**  
  `TasksController.subtasks_statistic` — циклически (раз в 100 сек) проверяет длину очереди подзадач, среднее значение, количество решённых/неудачных/затраченных впустую задач. Всё это — в виде печати и для графиков.
- **Расчёт продуктивности:**  
  `TasksController.calc_productivity` — сначала копит данные 300 секунд, далее циклично (раз в 10 сек) вычисляет продуктивность по количеству решённых задач и их времени выполнения.
- **Построение графиков:**  
  Каждая метрика (количество подзадач, интенсивность, продуктивность) передаётся в свой отдельный процесс, где строится график на лету.

---