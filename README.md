# Подробная блок-схема процессов и переменных

## 1. Основные переменные и структуры

**Классы и структуры:**
- `TasksGenerator` — генератор задач.
- `TasksExecutor` — вычислитель (ИА), который решает задачи.
- `TasksController` — вспомогательные методы (сбор статистики, работа с очередями, расчет продуктивности и др.).
- `Task` — описание типов задач, методы для получения их характеристик.
- `PriorityQueue` — очередь подзадач.
- Различные классы для построения графиков: `SubtasksCountInTaskPlot`, `SubtasksCountInQueuePlot`, `InputFlowPlot`, `ProductivityPlot`.

**Главные переменные:**
- `subtasks_queue` — очередь подзадач (PriorityQueue).
- `subtask_array` — массив подзадач (proxy.list()).
- `failed_subtasks` — очередь неудачных задач.
- `solved_tasks` — список решённых задач по типам.
- `namespace` — общая память между процессами (proxy.Namespace()).
  - `each_type_created_tasks_count` — число созданных задач по типам.
  - `input_flow` — интенсивность входящего потока.
- `executor_namespace` — общая память для вычислителей.
  - `solved_tasks_checker_flag`, `each_type_solved_subtasks_count`, `each_type_failed_subtasks_count`, `each_type_wasted_tasks_count`, `actual_task_execution_time`, `productivity`.
- `subtasks_count_in_task_queue` — очередь для сбора статистики количества подзадач в задачах.
- `stop_event` — флаг остановки всех процессов.

## 2. Последовательность запуска процессов

**Основной поток (`main.py`):**
1. Чтение конфигурации.
2. Инициализация всех очередей, списков и пространств имен.
3. Создание экземпляров генератора задач, исполнительных и управляющих классов.
4. Запуск 4 процессов-генераторов задач (`TasksGenerator.generate_tasks`).
5. Запуск процесса отправки задач в общую очередь (`TasksController.send_subtasks_to_queue`).
6. Запуск 32 вычислителей (`TasksExecutor.execute_tasks`) — каждый отдельный процесс, имитирующий отдельный ИА.
7. Запуск процесса-обработчика флага проверки решённых задач (`TasksController.switch_solved_tasks_checker_flag`).
8. Запуск процесса сбора статистики очереди подзадач (`TasksController.subtasks_statistic`).
9. Запуск процесса расчёта продуктивности (`TasksController.calc_productivity`).
10. Запуск процессов построения графиков:
    - Количество подзадач в задачах (`SubtasksCountInTaskPlot.plot_subtasks_count_in_tasks_by_time`)
    - Количество подзадач в очереди (`SubtasksCountInQueuePlot.plot_subtasks_count_in_queue_by_time`)
    - Интенсивность входного потока (`InputFlowPlot.plot_input_flow`)
    - Продуктивность (`ProductivityPlot.plot_productivity`)

**Завершение работы:**  
При нажатии Ctrl+C или другой остановке, всем процессам посылается сигнал остановки (`stop_event.set()`), далее выполняется корректное завершение и очистка.

## 3. Принцип работы каждого ИА (вычислителя)

**Вычислитель (`TasksExecutor.execute_tasks`):**
- Получает задачу из очереди `subtasks_queue`.
- Проверяет, не была ли задача уже решена.
- Запускает вычисление задачи, замеряет время.
- Если задача решена — добавляет её метку времени в список решённых задач `solved_tasks[task_type]`.
- Если задача не решена — увеличивает счётчик неудач, отправляет задачу обратно в очередь с максимальным приоритетом.
- Если время выполнения превышено — задача отмечается как "затраченная впустую".
- Все вычисления и состояния отражаются в `executor_namespace`.

## 4. Сбор и вычисление статистических данных

- **Сбор статистики по очереди:**  
  `TasksController.subtasks_statistic` — циклически (раз в 100 сек) проверяет длину очереди подзадач, среднее значение, количество решённых/неудачных/затраченных впустую задач. Всё это — в виде печати и для графиков.
- **Расчёт продуктивности:**  
  `TasksController.calc_productivity` — сначала копит данные 300 секунд, далее циклично (раз в 10 сек) вычисляет продуктивность по количеству решённых задач и их времени выполнения.
- **Построение графиков:**  
  Каждая метрика (количество подзадач, интенсивность, продуктивность) передаётся в свой отдельный процесс, где строится график на лету.

---

## 5. Блок-схема (описание в псевдографике)

```mermaid
flowchart TD
    A[Старт программы] --> B[Чтение конфигов, инициализация]
    B --> C1[Запуск 4 генераторов задач]
    B --> C2[Запуск менеджера очереди]
    B --> C3[Запуск 32 вычислителей (ИА)]
    B --> C4[Запуск сбора статистики]
    B --> C5[Запуск расчёта продуктивности]
    B --> C6[Запуск построения графиков]

    C1 --> D1[Генерация задач → массив подзадач]
    D1 --> C2

    C2 --> D2[Отправка задач в очередь подзадач]

    C3 --> D3[Получение задачи из очереди]
    D3 --> D4{Задача решена?}
    D4 -- Да --> D5[Регистрируем как решённую]
    D4 -- Нет --> D6[Возврат в очередь/увеличение счётчика неудач]
    D5 & D6 --> C4

    C4 --> E1[Сбор статистики: очередь, решённые, потерянные задачи]
    E1 --> C6

    C5 --> E2[Вычисление продуктивности]
    E2 --> C6

    C6 --> F1[Построение и отображение графиков]

    F1 --> G[Ожидание/Остановка]
    G -- Стоп/Сигнал --> H[Завершение процессов]
```

---

## 6. Краткое описание переменных и их функций

| Переменная/структура | Назначение |
|---|---|
| `subtasks_queue` | Общая очередь подзадач для вычислителей |
| `failed_subtasks` | Очередь неудачных задач |
| `solved_tasks` | Список решённых задач по типам |
| `namespace` | Пространство для обмена данными между процессами |
| `executor_namespace` | Пространство обмена для вычислителей (ИА) |
| `subtasks_count_in_task_queue` | Очередь для сбора статистики по задачам |
| `stop_event` | Флаг остановки всех процессов |

---

## 7. Пример работы одного вычислителя (ИА)

1. Получает задачу из очереди.
2. Если задача уже решена — пропускает.
3. Пытается решить задачу.
4. Если неудача — увеличивает счётчик и возвращает задачу.
5. Если задача решена — добавляет в `solved_tasks`.
6. Если затрачено слишком много времени — заносит в список "затраченных впустую".

---

## 8. Как устроены сбор и вычисление статистики

- Каждый процесс-вычислитель и генератор пишет свои данные в общие структуры (`namespace`, `executor_namespace`).
- Отдельные процессы-статистики (из `TasksController`) периодически опрашивают очереди/масивы и считают средние значения, суммарные показатели, продуктивность.
- Для визуализации все показатели передаются в отдельные процессы, строящие графики с помощью matplotlib.

---